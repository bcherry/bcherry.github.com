<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Adequately Good - Posts tagged “module pattern”</title>

    <!-- CSS, including Blueprint, jQuery w/Smoothness, and AG CSS -->
    <link rel="stylesheet" href="/css/blueprint/blueprint.min.css" media="screen, projection" />
    <link rel="stylesheet" href="/css/blueprint/print.min.css" media="print" />
    <!--[if lt IE 8]>
      <link rel="stylesheet" href="/css/blueprint/ie.css" media="screen, projection">
    <![endif]-->
    <link rel="stylesheet" href="/css/jquery-ui-smoothness/jquery-ui-1.7.2.custom.min.css" />
    <link rel="stylesheet" href="/css/ag.css" media="screen" />

    <!-- Extra <head> Links -->
    <link rel="alternate" type="application/atom+xml" title="Adequately Good Atom Feed" href="" />

    <!-- TODO: favicon -->

    <!-- IE HTML5 Compatibility -->
    <!--[if IE]>
      <script type="text/javascript">
        (function () {
          var tags = "header hgroup nav article time footer".split(" "),
            i = 0,
            l = tags.length;
          for (; i < l; i += 1) {
            document.createElement(tags[i]);
          }
        }());
      </script>
    <![endif]-->
  </head>
  <body>
    <a name="top"></a>
    <div id="container" class="container">

      <!-- Header -->
      <header class="span-24 last">
        <!-- Title -->
        <div id="title" class="span-24 last">
          <div class="span-17 colborder prepend-top append-bottom">
            <hgroup>
              <h1>
                <a href="/">adequately good</a>
              </h1>
              <h3 class="prepend-2 alt">decent programming advice</h3>
            </hgroup>
          </div>
          <div class="span-6 last prepend-top append-bottom">
            <h2>
              written by
              <a href="http://twitter.com/bcherry">ben cherry</a>
            </h2>
          </div>
        </div>

        <hr />

        <!-- Navigation Bar -->
        <nav class="prepend-2 span-20 append-2 last append-bottom">
          <div class="span-5">
            <a href="/">home</a>
          </div>
          <div class="span-5">
            <a href="#" id="archiveLink">archives</a>
          </div>
          <div class="span-5">
            <a href="/About-Ben">about</a>
          </div>
          <div class="span-5 last">
            <a href="">feed</a>
          </div>
        </nav>

        <!-- Archives Links -->
        <div id="archives" class="span-24 last smallalts" style="display:none;">
          <hr />
          <div class="archivelinks">
            <span class="alt">posts by year</span>
            
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
                  <a class="tight" href="/2009">2009</a>
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
              
            
              
                
                
                
                  <a class="tight" href="/2010">2010</a>
                
              
            
              
                
                
                
              
            
              
                
                
                
                  <a class="tight" href="/2011">2011</a>
                
              
            
          </div>
        </div>

        <hr />
      </header>

      <div id="colcontainer" class="span-24 last">
        <!-- Main content: Posts, etc. -->
        <div id="content" class="span-17 colborder">
          <a name="main"></a>
          <div class="smallalts listing">
  <span class="alt">all posts filed under</span>
  <a class="tight" href="/tags/module%20pattern">module pattern</a>
</div>

  

  

  

  
    <article class="span-17 last">
  <header class="span-17 last">
  
    <time class="alt" datetime="2010-07-08" pubdate>2010-07-08</time>
  
  <h1><a href="/2010/7/Writing-Testable-JavaScript">Writing Testable JavaScript</a></h1>
</header>
  <div class="span-17 last entry">
    <p>The engineering culture at Twitter requires tests. Lots of tests. I haven&#8217;t had formal experience with JavaScript testing before Twitter, so I&#8217;ve been learning a lot as I go. In particular, a number of patterns I used to use, write about, and encourage have turned out to be bad for writing testable code. So I thought it would be worthwhile to share a few of the most important principles I&#8217;ve developed for writing testable JavaScript. The examples I provide are based on <a href='http://docs.jquery.com/QUnit'>QUnit</a>, but should be just as applicable to any JavaScript testing framework.</p>

<h2 id='avoid_singletons'>Avoid Singletons</h2>

<p>One of my most popular posts was about using <a href='http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth'>JavaScript Module Pattern</a> to create powerful <strong>singletons</strong> in your application. This approach can be simple and useful, but it creates problems for testing, for one simple reason: <strong><em>singletons suffer state pollution between tests</em></strong>. Rather than creating your singletons as modules, you should compose them as constructable objects, and assign a single, default instance at the global level in your application init.</p>

<p>For example, consider the following singleton module (contrived example, of course):</p>

<pre><code>var dataStore = (function() {
	var data = [];
	return {
		push: function (item) {
			data.push(item);
		},
		pop: function() {
			return data.pop();
		},
		length: function() {
			return data.length;
		}
	};
}());</code></pre>

<p>With this module, we may wish to test the <code>foo.bar</code> method. Here&#8217;s a simple QUnit test suite:</p>

<pre><code>module(&quot;dataStore&quot;);
test(&quot;pop&quot;, function() {
	dataStore.push(&quot;foo&quot;);
	dataStore.push(&quot;bar&quot;)
	equal(dataStore.pop(), &quot;bar&quot;, &quot;popping returns the most-recently pushed item&quot;);
});

test(&quot;length&quot;, function() {
	dataStore.push(&quot;foo&quot;);
	equal(dataStore.length(), 1, &quot;adding 1 item makes the length 1&quot;);
});</code></pre>

<p>When running this test suite, the assertion in the <code>length</code> test will fail, but it&#8217;s not clear from looking at it why it should. The problem is that state has been left in <code>dataStore</code> from the previous test. Merely re-ordering these tests will cause the <code>length</code> test to pass, which is a clear red flag that something is wrong. We could fix this with setup or teardown that reverts the state of <code>dataStore</code>, but that means that we need to constantly maintain our test boilerplate as we make implementation changes in the <code>dataStore</code> module. A better approach is the following:</p>

<pre><code>function newDataStore() {
	var data = [];
	return {
		push: function (item) {
			data.push(item);
		},
		pop: function() {
			return data.pop();
		},
		length: function() {
			return data.length;
		}
	};
}

var dataStore = newDataStore();</code></pre>

<p>Now, your test suite will look like this:</p>

<pre><code>module(&quot;dataStore&quot;);
test(&quot;pop&quot;, function() {
	var dataStore = newDataStore();
	dataStore.push(&quot;foo&quot;);
	dataStore.push(&quot;bar&quot;)
	equal(dataStore.pop(), &quot;bar&quot;, &quot;popping returns the most-recently pushed item&quot;);
});

test(&quot;length&quot;, function() {
	var dataStore = newDataStore();
	dataStore.push(&quot;foo&quot;);
	equal(dataStore.length(), 1, &quot;adding 1 item makes the length 1&quot;);
});</code></pre>

<p>This allows our global <code>dataStore</code> to behave exactly as it did before, while allowing our tests to avoid polluting each other. Each test owns its own instance of a <code>DataStore</code> object, which will be garbage collected when the test completes.</p>

<h2 id='avoid_closurebased_privacy'>Avoid Closure-based Privacy</h2>

<p>Another pattern I used to promote is <a href='http://www.crockford.com/javascript/private.html'>real private members in JavaScript</a>. The advantage is that you can keep globally-accessible namespaces free of unnecessary references to private implementation details. However, overuse of this pattern can lead to untestable code. This is because <strong><em>your test suite cannot access, and thus cannot test, private functions hidden in closures</em></strong>. Consider the following:</p>

<pre><code>function Templater() {
	function supplant(str, params) {
		for (var prop in params) {
			str.split(&quot;{&quot; + prop +&quot;}&quot;).join(params[prop]);
		}
		return str;
	}

	var templates = {};

	this.defineTemplate = function(name, template) {
		templates[name] = template;
	};

	this.render = function(name, params) {
		if (typeof templates[name] !== &quot;string&quot;) {
			throw &quot;Template &quot; + name + &quot; not found!&quot;;
		}

		return supplant(templates[name], params);
	};
}</code></pre>

<p>The crucial method for our <code>Templater</code> object is <code>supplant</code>, but we cannot access it from outside the closure of the constructor. Thus, a testing suite like QUnit cannot hope to verify that it works as intended. In addition, we cannot verify that our <code>defineTemplate</code> method does anything without trying a <code>.render()</code> call on the template and watching for an exception. We could simply add a <code>getTemplate()</code> method, but then we&#8217;d be adding methods to the public interface solely to allow testing, which is not a good approach. While the issues here are probably just fine in this simple example, building complex objects with important private methods will lead to relying on untestable code, which is a red flag. Here&#8217;s a testable version of the above:</p>

<pre><code>function Templater() {
	this._templates = {};
}

Templater.prototype = {
	_supplant: function(str, params) {
		for (var prop in params) {
			str.split(&quot;{&quot; + prop +&quot;}&quot;).join(params[prop]);
		}
		return str;
	},
	render: function(name, params) {
		if (typeof this._templates[name] !== &quot;string&quot;) {
			throw &quot;Template &quot; + name + &quot; not found!&quot;;
		}

		return this._supplant(this._templates[name], params);
	},
	defineTemplate: function(name, template) {
		this._templates[name] = template;
	}
};</code></pre>

<p>And here&#8217;s a QUnit test suite for it:</p>

<pre><code>module(&quot;Templater&quot;);
test(&quot;_supplant&quot;, function() {
	var templater = new Templater();
	equal(templater._supplant(&quot;{foo}&quot;, {foo: &quot;bar&quot;}), &quot;bar&quot;))
	equal(templater._supplant(&quot;foo {bar}&quot;, {bar: &quot;baz&quot;}), &quot;foo baz&quot;));
});

test(&quot;defineTemplate&quot;, function() {
	var templater = new Templater();
	templater.defineTemplate(&quot;foo&quot;, &quot;{foo}&quot;);
	equal(template._templates.foo, &quot;{foo}&quot;);
});

test(&quot;render&quot;, function() {
	var templater = new Templater();
	templater.defineTemplate(&quot;hello&quot;, &quot;hello {world}!&quot;);
	equal(templater.render(&quot;hello&quot;, {world: &quot;internet&quot;}), &quot;hello internet!&quot;);
});</code></pre>

<p>Notice that our test for <code>render</code> is really just a test that <code>defineTemplate</code> and <code>supplant</code> integrate correctly with each other. We&#8217;ve already tested those methods in isolation, which will allow us to easily discover which components are really breaking when tests of the <code>render</code> method fail.</p>

<h2 id='write_tight_functions'>Write Tight Functions</h2>

<p>Tight functions are important in any language, but JavaScript presents its own reasons to do so. Much of what you do with JavaScript is done against global singletons provided by the environment, and which your test suite relies on. For instance, testing a URL re-writer will be difficult if all of your methods try to assign <code>window.location</code>. Instead, you should <strong><em>break your system into its logical components that decide what to do, then write short functions that actually do it</em></strong>. You can test the logical functions with various inputs and outputs, and leave the final function that modifies <code>window.location</code> untested. Provided you&#8217;ve composed your system correctly, this should be safe.</p>

<p>Here&#8217;s an example URL rewriter that is not testable:</p>

<pre><code>function redirectTo(url) {
	if (url.charAt(0) === &quot;#&quot;) {
		window.location.hash = url;
	} else if (url.charAt(0) === &quot;/&quot;) {
		window.location.pathname = url;
	} else {
		window.location.href = url;
	}
}</code></pre>

<p>The logic in this example is relatively simple, but we can imagine a more complex redirecter. As complexity grows, we will not be able to test this method without causing the window to redirect, thus leaving our test suite entirely.</p>

<p>Here&#8217;s a testable version:</p>

<pre><code>function _getRedirectPart(url) {
	if (url.charAt(0) === &quot;#&quot;) {
		return &quot;hash&quot;;
	} else if (url.charAt(0) === &quot;/&quot;) {
		return &quot;pathname&quot;;
	} else {
		return &quot;href&quot;;
	}
}

function redirectTo(url) {
	window.location[_getRedirectPart(url)] = url;
}</code></pre>

<p>And now we can write a simple test suite for <code>_getRedirectPart</code>:</p>

<pre><code>test(&quot;_getRedirectPart&quot;, function() {
	equal(_getRedirectPart(&quot;#foo&quot;), &quot;hash&quot;);
	equal(_getRedirectPart(&quot;/foo&quot;), &quot;pathname&quot;);
	equal(_getRedirectPart(&quot;http://foo.com&quot;), &quot;href&quot;);
});</code></pre>

<p>Now the meat of <code>redirectTo</code> has been tested, and we don&#8217;t have to worry about accidentally redirecting out of our test suite.</p>
<span class='note'>__Note__: There is an alternative solution, which is to create a `performRedirect` function that does the location change, but stub that out in your test suite.	 This is a common practice for many, but I've been trying to avoid method stubbing.	 I find basic QUnit to work well in all situations I've found so far, and would prefer to not have to remember to stub out a method like that for my tests, but your case may differ.</span>
<h2 id='write_lots_of_tests'>Write Lots of Tests</h2>

<p>This is a no-brainer, but it&#8217;s important to remember. Many programmers write too few tests because writing tests is hard, or lots of work. I suffer from this problem all the time, so I threw together a little helper for QUnit that makes writing lots of tests a lot easier. It&#8217;s a function called <code>testCases</code> which you call within a <code>test</code> block, passing a function, calling context, and array of inputs/outputs to try and compare. You can quickly build up a robust suite for your input/output functions for rigorous testing.</p>

<pre><code>function testCases(fn, context, tests) {
	for (var i = 0; i &lt; tests.length; i++) {
		same(fn.apply(context, tests[i][0]), tests[i][1],
			tests[i][2] || JSON.stringify(tests[i]));
	}
}</code></pre>

<p>And here&#8217;s a simple example use:</p>

<pre><code>test(&quot;foo&quot;, function() {
	testCases(foo, null, [
		[[&quot;bar&quot;, &quot;baz&quot;], &quot;barbaz&quot;],
		[[&quot;bar&quot;, &quot;bar&quot;], &quot;barbar&quot;, &quot;a passing test&quot;]
	]);
});</code></pre>

<h2 id='conclusions'>Conclusions</h2>

<p>There is plenty more to write about testable JavaScript, and I&#8217;m sure there are many good books, but I hope this was a good overview of practical cases I encounter on a daily basis. I&#8217;m by no means a testing expert, so please let me know if I&#8217;ve made mistakes or given bad advice.</p>
  </div>
</article>

  

  

  
    <article class="span-17 last">
  <header class="span-17 last">
  
    <time class="alt" datetime="2010-04-13" pubdate>2010-04-13</time>
  
  <h1><a href="/2010/4/Debugging-Closures-and-Modules">Debugging Closures and Modules</a></h1>
</header>
  <div class="span-17 last entry">
    <p>The most common complaint with using closures to keep private variables in JavaScript is that it makes debugging harder. This complaint definitely holds water, and the loss of easy debugging and inspection using the <a href='http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth'>Module Pattern</a> is a serious concern. This is where one of JavaScript&#8217;s non-standard but well-supported features comes in: the <strong>debugger statement</strong>. In this article, I&#8217;ll introduce this statement, and show how I use it to solve this deficiency in closure-based code.</p>

<h2 id='intro_to_'>Intro to <code>debugger</code></h2>

<p>The <code>debugger</code> statement is not standardized, but <strong>is provided by all implementations</strong> of JavaScript. It essentially acts like a programmatic breakpoint. When popular JavaScript debuggers like Firebug or the IE Developer Tools execute a <code>debugger;</code> statement, execution stops and the script debugger opens up, just like any breakpoint. Here&#8217;s a simple example:</p>

<pre><code>function foo() {
	var a = 1;
	debugger; // execution stops until manually resumed
	a = 2;
}
foo();</code></pre>

<p>In the above, we&#8217;ll be able to inspect the local variables when our debugger pauses execution, and we&#8217;ll see that <code>a</code> is still <code>1</code>. After resuming execution, the next line will execute and <code>a</code> will be assigned the value <code>2</code>.</p>

<h2 id='debugging_modules'>Debugging Modules</h2>

<p>The great thing is that execution stops at the <code>debugger</code> statement, complete with the local call stack from the point of execution. This provides a really nice ability to pair with the module pattern, or any other closure-based privacy pattern. Let&#8217;s take a simple module, but add extra capabilities to it by exposing a public <code>.debug()</code> method.</p>

<pre><code>var foo = (function () {
	var privateVar = 10;
	return {
		publicFunc: function () {/*...*/},
		debug: function () {
			debugger;
		}
	};
}());</code></pre>

<p>Now we can call <code>foo.debug()</code> from the Firebug console, and the closure of the anonymous constructor is opened up for inspection. By looking at the <strong>call stack</strong> in our debugger, we can inspect the <strong>scope chain</strong> for the private state, which will be in local variables. Checking the value of <code>privateVar</code> will be quite easy.</p>

<p>Notice that it&#8217;s very important for the <code>.debug()</code> property to be created and assigned during the normal construction. Assigning it after-the-fact will not provide the same functionality, because the local call stack will not contain the anonymous constructor. This is an unfortunate limitation, but there isn&#8217;t a way around it.</p>

<h2 id='safety_and_configuration'>Safety and Configuration</h2>

<p>You might not want to make it so easy to stop program execution by triggering the <code>.debug()</code> function on one of your modules, or you might want to disable this functionality. One approach is to ship a version of your code without this property at all, but that&#8217;s difficult to accomplish in some applications. An easier method would be to do some extra checks in the <code>.debug()</code> method, before firing the <code>debugger</code> statement.</p>

<pre><code>return {
	debug: function () {
		if (DEBUG_MODE) {
			debugger;
		}
	}
};</code></pre>

<p>Or, perhaps check for a specific debugger first:</p>

<pre><code>return {
	debug: function () {
		if (DEBUG_MODE &amp;&amp; &quot;firebug&quot; in console) {
			debugger;
		}
	}
};</code></pre>
<span class='note'>___Note___: I'm assuming you've already configured a global flag named `DEBUG_MODE` in your application.</span>
<p>Methods like this will allow you to provide finer-grained control over when and where your <code>debugger</code> statement runs. If you&#8217;re building in a lot of logic, it makes sense to write a global helper function for this, but you&#8217;ll have to be careful to preserve the right call stack:</p>

<pre><code>function DEBUG() {
	if (DEBUG_MODE &amp;&amp; &quot;firebug&quot; in console) {
		debugger;
	}
}

var foo = (function () {
	return {
		debug: function () {
			DEBUG();
		}
	};
}());</code></pre>

<p>Here we&#8217;ll keep our callstack in tact, except the one we care about will be two deep instead of one deep.</p>

<h3 id='problems_with_minifiers'>Problems With Minifiers</h3>

<p>I tried running code with such a <code>.debug()</code> method through the YUI Compressor, and got a disappointing result:</p>

<pre><code>[ERROR] 4:11:identifier is a reserved word</code></pre>

<p>It seems that the YUI Compressor doesn&#8217;t know about the <code>debugger</code> statement, which is understandable since it&#8217;s non-standard. However, I didn&#8217;t want to let this defeat my attempts, so a co-worker and I came up with a workaround. Instead of using a raw <code>debugger</code> statement, we put it behind <code>eval</code>, like this:</p>

<pre><code>function debug() {
	eval(&#39;debugger;&#39;);
}</code></pre>

<p>Now YUI no longer complains, and the code works just great. However, there are a few caveats here:</p>

<ol>
<li>Using <code>eval</code> is generally considered <strong>dangerous</strong> and <strong>bad practice</strong>. Be sure you understand the implications, and are willing to use this workaround anyways. I think this is a reasonable decision to make, for the intended purpose, but ensure you&#8217;ve at least put some thought into it.</li>

<li>JSLint will complain at you. This isn&#8217;t such a big deal since it would be complaining about the raw <code>debugger</code> statement anyways.</li>
</ol>

<h2 id='conclusions'>Conclusions</h2>

<p>So that&#8217;s my technique for effectively debugging inside closures, especially when using the Module Pattern. I&#8217;m not saying this is a great technique for all uses or users, but it works well for me, and nicely solves the most common complaint developers have about the Module Pattern. I&#8217;d love to hear alternatives or reasons why my technique is dangerous and should be avoided, so leave a comment!</p>
  </div>
</article>

  

  

  

  

  
    <article class="span-17 last">
  <header class="span-17 last">
  
    <time class="alt" datetime="2010-03-12" pubdate>2010-03-12</time>
  
  <h1><a href="/2010/3/JavaScript-Module-Pattern-In-Depth">JavaScript Module Pattern: In-Depth</a></h1>
</header>
  <div class="span-17 last entry">
    <p>The module pattern is a common JavaScript coding pattern. It&#8217;s generally well understood, but there are a number of advanced uses that have not gotten a lot of attention. In this article, I&#8217;ll review the basics and cover some truly remarkable advanced topics, including one which I think is original.</p>

<h2 id='the_basics'>The Basics</h2>

<p>We&#8217;ll start out with a simple overview of the module pattern, which has been well-known since Eric Miraglia (of YUI) first <a href='http://yuiblog.com/blog/2007/06/12/module-pattern/'>blogged about it</a> three years ago. If you&#8217;re already familiar with the module pattern, feel free to skip ahead to &#8220;Advanced Patterns&#8221;.</p>

<h3 id='anonymous_closures'>Anonymous Closures</h3>

<p>This is the fundamental construct that makes it all possible, and really is the single <strong>best feature of JavaScript</strong>. We&#8217;ll simply create an anonymous function, and execute it immediately. All of the code that runs inside the function lives in a <strong>closure</strong>, which provides <strong>privacy</strong> and <strong>state</strong> throughout the lifetime of our application.</p>

<pre><code>(function () {
	// ... all vars and functions are in this scope only
	// still maintains access to all globals
}());</code></pre>

<p>Notice the <code>{@class=js inline}()</code> around the anonymous function. This is required by the language, since statements that begin with the token <code>{@class=js inline}function</code> are always considered to be <strong>function declarations</strong>. Including <code>{@class=js inline}()</code> creates a <strong>function expression</strong> instead.</p>

<h3 id='global_import'>Global Import</h3>

<p>JavaScript has a feature known as <strong>implied globals</strong>. Whenever a name is used, the interpreter walks the scope chain backwards looking for a <code>{@class=js inline}var</code> statement for that name. If none is found, that variable is assumed to be global. If it&#8217;s used in an assignment, the global is created if it doesn&#8217;t already exist. This means that using or creating global variables in an anonymous closure is easy. Unfortunately, this leads to hard-to-manage code, as it&#8217;s not obvious (to humans) which variables are global in a given file.</p>

<p>Luckily, our anonymous function provides an easy alternative. By passing globals as parameters to our anonymous function, we <strong>import</strong> them into our code, which is both <strong>clearer</strong> and <strong>faster</strong> than implied globals. Here&#8217;s an example:</p>

<pre><code>(function ($, YAHOO) {
	// now have access to globals jQuery (as $) and YAHOO in this code
}(jQuery, YAHOO));</code></pre>

<h3 id='module_export'>Module Export</h3>

<p>Sometimes you don&#8217;t just want to <em>use</em> globals, but you want to <em>declare</em> them. We can easily do this by exporting them, using the anonymous function&#8217;s <strong>return value</strong>. Doing so will complete the basic module pattern, so here&#8217;s a complete example:</p>

<pre><code>var MODULE = (function () {
	var my = {},
		privateVariable = 1;

	function privateMethod() {
		// ...
	}

	my.moduleProperty = 1;
	my.moduleMethod = function () {
		// ...
	};

	return my;
}());</code></pre>

<p>Notice that we&#8217;ve declared a global module named <code>{@class=js inline}MODULE</code>, with two public properties: a method named <code>{@class=js inline}MODULE.moduleMethod</code> and a variable named <code>{@class=js inline}MODULE.moduleProperty</code>. In addition, it maintains <strong>private internal state</strong> using the closure of the anonymous function. Also, we can easily import needed globals, using the pattern we learned above.</p>

<h2 id='advanced_patterns'>Advanced Patterns</h2>

<p>While the above is enough for many uses, we can take this pattern farther and create some very powerful, extensible constructs. Lets work through them one-by-one, continuing with our module named <code>{@class=js inline}MODULE</code>.</p>

<h3 id='augmentation'>Augmentation</h3>

<p>One limitation of the module pattern so far is that the entire module must be in one file. Anyone who has worked in a large code-base understands the value of splitting among multiple files. Luckily, we have a nice solution to <strong>augment modules</strong>. First, we import the module, then we add properties, then we export it. Here&#8217;s an example, augmenting our <code>{@class=js inline}MODULE</code> from above:</p>

<pre><code>var MODULE = (function (my) {
	my.anotherMethod = function () {
		// added method...
	};

	return my;
}(MODULE));</code></pre>

<p>We use the <code>{@class=js inline}var</code> keyword again for consistency, even though it&#8217;s not necessary. After this code has run, our module will have gained a new public method named <code>{@class=js inline}MODULE.anotherMethod</code>. This augmentation file will also maintain its own private internal state and imports.</p>

<h3 id='loose_augmentation'>Loose Augmentation</h3>

<p>While our example above requires our initial module creation to be first, and the augmentation to happen second, that isn&#8217;t always necessary. One of the best things a JavaScript application can do for performance is to load scripts asynchronously. We can create flexible multi-part modules that can load themselves in any order with <strong>loose augmentation</strong>. Each file should have the following structure:</p>

<pre><code>var MODULE = (function (my) {
	// add capabilities...

	return my;
}(MODULE || {}));</code></pre>

<p>In this pattern, the <code>{@class=js inline}var</code> statement is always necessary. Note that the import will create the module if it does not already exist. This means you can use a tool like <a href='http://labjs.com/'>LABjs</a> and load all of your module files in parallel, without needing to block.</p>

<h3 id='tight_augmentation'>Tight Augmentation</h3>

<p>While loose augmentation is great, it does place some limitations on your module. Most importantly, you cannot override module properties safely. You also cannot use module properties from other files during initialization (but you can at run-time after intialization). <strong>Tight augmentation</strong> implies a set loading order, but allows <strong>overrides</strong>. Here is a simple example (augmenting our original <code>{@class=js inline}MODULE</code>):</p>

<pre><code>var MODULE = (function (my) {
	var old_moduleMethod = my.moduleMethod;

	my.moduleMethod = function () {
		// method override, has access to old through old_moduleMethod...
	};

	return my;
}(MODULE));</code></pre>

<p>Here we&#8217;ve overridden <code>{@class=js inline}MODULE.moduleMethod</code>, but maintain a reference to the original method, if needed.</p>

<h3 id='cloning_and_inheritance'>Cloning and Inheritance</h3>

<pre><code>var MODULE_TWO = (function (old) {
	var my = {},
		key;

	for (key in old) {
		if (old.hasOwnProperty(key)) {
			my[key] = old[key];
		}
	}

	var super_moduleMethod = old.moduleMethod;
	my.moduleMethod = function () {
		// override method on the clone, access to super through super_moduleMethod
	};

	return my;
}(MODULE));</code></pre>

<p>This pattern is perhaps the <strong>least flexible</strong> option. It does allow some neat compositions, but that comes at the expense of flexibility. As I&#8217;ve written it, properties which are objects or functions will <em>not</em> be duplicated, they will exist as one object with two references. Changing one will change the other. This could be fixed for objects with a recursive cloning process, but probably cannot be fixed for functions, except perhaps with <code>{@class=js inline}eval</code>. Nevertheless, I&#8217;ve included it for completeness.</p>

<h3 id='crossfile_private_state'>Cross-File Private State</h3>

<p>One severe limitation of splitting a module across multiple files is that each file maintains its own private state, and does not get access to the private state of the other files. This can be fixed. Here is an example of a loosely augmented module that will <strong>maintain private state</strong> across all augmentations:</p>

<pre><code>var MODULE = (function (my) {
	var _private = my._private = my._private || {},
		_seal = my._seal = my._seal || function () {
			delete my._private;
			delete my._seal;
			delete my._unseal;
		},
		_unseal = my._unseal = my._unseal || function () {
			my._private = _private;
			my._seal = _seal;
			my._unseal = _unseal;
		};

	// permanent access to _private, _seal, and _unseal

	return my;
}(MODULE || {}));</code></pre>

<p>Any file can set properties on their local variable <code>{@class=js inline}_private</code>, and it will be immediately available to the others. Once this module has loaded completely, the application should call <code>{@class=js inline}MODULE._seal()</code>, which will prevent external access to the internal <code>{@class=js inline}_private</code>. If this module were to be augmented again, further in the application&#8217;s lifetime, one of the internal methods, in any file, can call <code>{@class=js inline}_unseal()</code> before loading the new file, and call <code>{@class=js inline}_seal()</code> again after it has been executed. This pattern occurred to me today while I was at work, I have not seen this elsewhere. I think this is a very useful pattern, and would have been worth writing about all on its own.</p>

<h3 id='submodules'>Sub-modules</h3>

<p>Our final advanced pattern is actually the simplest. There are many good cases for creating sub-modules. It is just like creating regular modules:</p>

<pre><code>MODULE.sub = (function () {
	var my = {};
	// ...

	return my;
}());</code></pre>

<p>While this may have been obvious, I thought it worth including. Sub-modules have all the advanced capabilities of normal modules, including augmentation and private state.</p>

<h2 id='conclusions'>Conclusions</h2>

<p>Most of the advanced patterns can be combined with each other to create more useful patterns. If I had to advocate a route to take in designing a complex application, I&#8217;d combine <strong>loose augmentation</strong>, <strong>private state</strong>, and <strong>sub-modules</strong>.</p>

<p>I haven&#8217;t touched on performance here at all, but I&#8217;d like to put in one quick note: The module pattern is <strong>good for performance</strong>. It minifies really well, which makes downloading the code faster. Using <strong>loose augmentation</strong> allows easy non-blocking parallel downloads, which also speeds up download speeds. Initialization time is probably a bit slower than other methods, but worth the trade-off. Run-time performance should suffer no penalties so long as globals are imported correctly, and will probably gain speed in sub-modules by shortening the reference chain with local variables.</p>

<p>To close, here&#8217;s an example of a sub-module that loads itself dynamically to its parent (creating it if it does not exist). I&#8217;ve left out private state for brevity, but including it would be simple. This code pattern allows an entire complex heirarchical code-base to be loaded completely in parallel with itself, sub-modules and all.</p>

<pre><code>var UTIL = (function (parent, $) {
	var my = parent.ajax = parent.ajax || {};

	my.get = function (url, params, callback) {
		// ok, so I&#39;m cheating a bit :)
		return $.getJSON(url, params, callback);
	};

	// etc...

	return parent;
}(UTIL || {}, jQuery));</code></pre>

<p>I hope this has been useful, and please leave a comment to share your thoughts. Now, go forth and write better, more modular JavaScript!</p>

<p><strong><em>This post was <a href='http://ajaxian.com/archives/a-deep-dive-and-analysis-of-the-javascript-module-pattern'>featured on Ajaxian.com</a>, and there is a little bit more discussion going on there as well, which is worth reading in addition to the comments below.</em></strong></p>
  </div>
</article>

  

  

  

  

  

  

  

  

  

  

  

  

  


        </div>

        <!-- Sidebar: Search, links, etc. -->
        <div id="sidebar" class="span-6 last">
          <hr class="space" />

          <div id="links">
            <h3>the author</h3>
            <p>
              Ben is a 25 year-old software engineer. He lives and works in San Francisco. Many people think he invented the term "hoisting" in JavaScript, but this is untrue.
            </p>
            <ul>
              <li><a href="http://twitter.com/bcherry">Twitter</a> - @<a class="twitter-anywhere-user" href="http://twitter.com/bcherry">bcherry</a></li>
              <li><a href="http://github.com/bcherry">GitHub</a> - My Code</li>
              <li><a href="http://www.linkedin.com/in/bcherryprogrammer">LinkedIn</a> - Professional Profile</li>
              <li><a href="http://www.facebook.com/bcherry">Facebook</a> - That Other Social Network</li>
              <li><a href="http://www.bcherry.net/talks/">Presentations</a> - Slides From My Talks</li>
            </ul>
            <iframe allowtransparency="true" frameborder="0" scrolling="no"
              src="http://platform.twitter.com/widgets/follow_button.html?screen_name=bcherry&amp;button=grey&amp;text_color=7F7F7F&amp;link_color=666666"
              style="width:300px; height:20px;"></iframe>
          </div>

          <hr />

          <div id="tags">
            <h3>categories</h3>
            <ul>
            
              <li>
                <a href="/tag/javascript">javascript</a>
                (18)
              </li>
            
              <li>
                <a href="/tag/social%20gaming">social gaming</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/performance">performance</a>
                (4)
              </li>
            
              <li>
                <a href="/tag/jquery">jquery</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/tools">tools</a>
                (2)
              </li>
            
              <li>
                <a href="/tag/html5">html5</a>
                (3)
              </li>
            
              <li>
                <a href="/tag/adequatelygood">adequatelygood</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/timers">timers</a>
                (2)
              </li>
            
              <li>
                <a href="/tag/module%20pattern">module pattern</a>
                (3)
              </li>
            
              <li>
                <a href="/tag/talks">talks</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/slide">slide</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/python">python</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/debugging">debugging</a>
                (1)
              </li>
            
              <li>
                <a href="/tag/testing">testing</a>
                (2)
              </li>
            
              <li>
                <a href="/tag/hashbang">hashbang</a>
                (1)
              </li>
            
            </ul>
          </div>

          <hr />

          
        </div>
      </div>
    </div>

    <!-- Exception Hub start -->
    <script src="http://js.exceptionhub.com/javascripts/eh.js"></script>
    <script>
    ExceptionHub.setup("8ff0f84d25456b049a9c1a83f8e62b56", 21, 'production');
    </script>
    <!-- Exception Hub end -->

    <script type="text/javascript" src="/js/jquery-1.3.2.min.js"></script>
    <!--<script type="text/javascript" src="/js/chili/jquery.chili-2.2.js"></script>-->
    <script type="text/javascript" src="/js/consul.js"></script>
    <script type="text/javascript">
      // ChiliBook.recipeFolder = "/js/chili/";
      consul.turnOn();
      jQuery.noConflict();

      var AG = {};
      // Page Script
    </script>

    <!-- Include LABjs and request the rest of the script files-->
    <script type="text/javascript" src="/js/LAB.min.js"></script>
    <script type="text/javascript">
      $LAB
      .script("/js/jquery-ui-1.7.2.custom.min.js")
      .script("/js/jquery.templates.js")
      .script("/js/base.js")
      .script("/js/ag.js")
    </script>

    <!-- Google Analytics -->
    <script type="text/javascript">var _gaq =_gaq||[]; _gaq.push(['_setAccount','UA-251077-4']);_gaq.push(['_trackPageview']);(function(){var ga=document.createElement('script');ga.type='text/javascript';ga.async=true;ga.src=('https:'==document.location.protocol?'https://ssl':'http://www')+'.google-analytics.com/ga.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(ga);})();</script>
  </body>
</html>
